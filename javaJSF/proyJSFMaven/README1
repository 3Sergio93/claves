Luego de la clase del 02/11/2017

Tarea0.

 construir y desplegar usando herramienta maven:

 mvn jetty:run  

 Notar que no tenemos como dependencia servidor tomee, y sí jetty.
 Según pom.xml, puerto que usará jetty server es 9999.

 Probar/acceder mediante http://localhost:9999

 Notar que con jetty no es necesario el 'contexto', el servidor 
 jetty 'sólo' estará sirvendo a esta aplicación.
 Mientras que si es tomee se accede con:
 
 http://localhost:9999/JSFMaven        <--- JSFMaven es nombre de
 contexto y definido en pom.xml
 
Tarea1.

Cambiamos el ámbito del ManagedBean, de Request lo pasamos a View
entonces procedemos a comentar @RequestScoped y usamos @ViewScoped

import javax.faces.bean.ViewScoped;

@ManagedBean(name="obj")
@ViewScoped
public class ViewManager implements Serializable{
  private String key;
  private String value;
  ...
  ...

  
  public String add() {
    System.out.println("=" + this.key + "=" + this.value + "=");
// setValue(this.value + "==");
    this.mensaje="Alta realizada";
    return null;
  }
}


Notar que la acción add, ahora retorna null, es lógico cuando el
ámbito es 'view' técnicamente ViewScoped.

¿Qué significa esto de los ámbitos?

RequestScoped:

  el objeto instanciado por el framework ('obj' en nuestro ejemplo)
  está 'vivo' durante toda la request, sabiendo que una request acaba
  cuando se envíó la respuesta al cliente.
  En nuestro ejemplo vemos y experimentamos este concepto al usar
  obj.mensaje en vista2.xhtml, esa vista es diferente a vista1.xhtml
  y todo ocurre "antes" de enviar la respuesta al cliente. Una vez
  enviada la vista2.xhtml el objeto 'obj' se destruye.

  En una línea: un objeto 'managedBean' persiste o existe lo que dura
  una request.

ViewScoped:

  En una línea: un objeto 'managedBean' es persistente hasta que se cambia
  de vista. 
  Mientras que se da como respuesta al cliente la misma vista, el objeto no
  se destruye.
  
  Notar que una vez ejecutada la acción (el método add en nuestro ejemplo)
  para entregar como respuesta la misma vista, basta con retornar 'null',
  esto es lo que hacemos en esta Tarea1.

  Notar que los cambios que exige esta tarea implica que la vista2.xhtml
  no juega ningún papel, como si no estuviera.
  
  Se construye el proyecto y prueba de la misma forma.

  Por último notar que habrá errores generados por el container por el hecho
  de usar el scope view, jetty y tomcat no tienen soporte CDI (cuestión ya
  experimentada en tp1, al menos debería estar trabajado por ti), aún así
  no va mal y el container termina resolviendo bien; resulta que ViewScoped
  necesita soporte CDI en el container, de otra forma se producen errores, que
  no afectan a nuestra aplicación tal como está en este momento.

Tarea2.
  
ViewScoped y conseguir persistencia de los datos enviados en cada request;
implementamos esa persistencia mediante Redis.

import javax.faces.bean.ViewScoped;
import redis.clients.jedis.Jedis;
@ManagedBean(name="obj")
@ViewScoped
public class ViewManager implements Serializable{
  private String key;
  private String value;
  ...
  ...
 
  public String add() {
    System.out.println("=" + this.key + "=" + this.value + "=");
// setValue(this.value + "==");
    this.mensaje="Alta realizada";
    Jedis conn = new Jedis("localhost");
    conn.hset("hashPrimero",this.key,this.value);
    return null;
  }
}

Notar que la persistencia en Redis es usando un hash.
  nombre del hash: hashPrimero
  nombre de campo o key: el de la key recogida del formulario HTML
  el valor: el valor recogido del formulario HTML

  Por cada request se crea una nueva key con su valor en la BD Redis,
  teniendo en cuenta que si en una request se repite una key ya existente,
  la misma no se crea nuevamente, los hash tienen keys únicas, sí machacaría
  el valor.

Tarea3.

Ahora que en Tarea2 hemos conseguido persistencia, incrementamos nuestra
vista1.xhtml, queremos mostrar las keys existentes, es decir que el cliente
web cada vez que envía el formulario (vista1.xhtml), verá como respuesta
todas las claves introducidas previamente, es decir todas las claves
que gestiona la aplicación (el cliente ni sabe que tipo de persistencia
se está utilizando en el server, el back-end, si file, si MySQL, etc),
pero sí persibe tal persistencia.

Procedemos con el siguiente cambio en vista1.xhtml

<h:form>
<p>Key:
<h:inputText value="#{obj.key}"/>
</p>
<p>Value:
<h:inputText value="#{obj.value}" />
</p>
<p>
<h:commandButton value="add" action="#{obj.add}" />
</p>
</h:form>

<h:dataTable value="#{obj.listClaves}" var="item">
  <h:column>
    #{obj.listClaves.indexOf(item)}
  </h:column>
  <h:column>
   <h:outputText value="#{item}" />
  </h:column>
</h:dataTable>
</h:body>
</html>

¿qué nos indica la notación #{obj.listClaves}?

  En el objeto managedBean entiende un método getListClaves, es decir
  la clase ViewManager debe ser extendida para esta tarea, vamos a ello.

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import javax.faces.bean.ViewScoped;
import redis.clients.jedis.Jedis;
@ManagedBean(name="obj")
@ViewScoped
public class ViewManager implements Serializable{
  private String key;
  private String value;
  private List<String> listClaves;
  ...
  ...
  public List<String> getListClaves() {
    Jedis conn = new Jedis("localhost");
    Set<String> unSet;
    unSet = conn.hkeys("hashPrimero");
    listClaves = new ArrayList<String>(unSet);
    return listClaves;
  }

  public void setListClaves(List<String> list) {
    this.listClaves = list;
  }
  
  public String add() {
    System.out.println("=" + this.key + "=" + this.value + "=");
// setValue(this.value + "==");
    this.mensaje="Alta realizada";
    Jedis conn = new Jedis("localhost");
    conn.hset("hashPrimero",this.key,this.value);
    return null;
  }
}

Interesante el uso de un tipo Set en el método getListClaves(). El método
de la API jedis hkeys retorna el conjunto de claves pero no como una lista
de String sino un "set de string".
  ¿Por qué habrán diseñado así a este método?.
Por definición un set contiene valores únicos, luego como las claves de
un hash son valores únicos, es ideal usar en el retorno del método hkeys
un tipo set.

Notar que una forma de convertir un Set en un List, es mediante el constructor
ArrayList, de la siguiente forma:
    listClaves = new ArrayList<String>(unSet); // según nuestro ejemplo

Y ¿Por qué necesitamos convertir al set en una lista?

La respuesta es por un pequeño detalle que estamos usando en la vista.
Tenemos:

<h:dataTable value="#{obj.listClaves}" var="item">

hasta aquí daría igual que sea una lista o un set el resultado de obj.listClaves
las tag h:dataTable espera que el valor del atributo value sean 'n' objetos
donde n puede ser 0 o 1 o bien > 1
Dichos n objetos en nuestro caso son objetos String, y h:dataTable trabajará
indistintamente con List como con Set.
El detalle particular de enviar una 'lista de String' viene fundamentado
aquí:
   <h:column>
    #{obj.listClaves.indexOf(item)}
   </h:column>

Se propone en una columna mostrar el índice, es decir que la lista de keys
que se le envía al cliente venga numerada. Sólo por esta razón. La clase
Set no tiene un método similar al método indexOf del tipo List, y sería más
complejo 'trabajando con un set en la vista' obtener tal numeración.


Tarea4.

Qué propones si se pide escribir en la respuesta no sólo el conjunto
de claves existentes, sino el conjunto de pares key-valor
Sabiendo que nos sirve para este requerimiento el mismo h:dataTable usado
en la vista, estaríamos agregando una columna, la del valor
